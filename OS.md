# 1. Архитектура ЭВМ. Режимы работы центрального процессора.

### Архитектура ЭВМ и режимы работы центрального процессора

#### Архитектура ЭВМ

**Архитектура ЭВМ (Электронно-Вычислительной Машины)** — это модель и функциональная организация компьютерных систем, включающая структуру, управление, реализацию и взаимодействие компонентов системы. Архитектура ЭВМ определяет принципы работы процессора, памяти, ввода-вывода и других компонентов, а также их взаимодействие.

Основные компоненты архитектуры ЭВМ:
1. **Центральный процессор (ЦПУ):** Основной исполнительный блок, выполняющий инструкции программ.
2. **Оперативная память (RAM):** Временное хранилище данных и инструкций, к которым процессор должен быстро обращаться.
3. **Устройства ввода-вывода (I/O):** Средства взаимодействия с внешними устройствами, такими как клавиатуры, мониторы, принтеры и т.д.
4. **Системная шина:** Средство передачи данных между процессором, памятью и устройствами ввода-вывода.

#### Основные элементы процессора:
- **Арифметико-логическое устройство (АЛУ):** Выполняет арифметические и логические операции.
- **Устройство управления (Control Unit):** Интерпретирует инструкции и управляет их выполнением.
- **Регистр:** Высокоскоростные хранилища данных внутри процессора для временного хранения данных и инструкций.
- **Кэш-память:** Быстрая память для хранения часто используемых данных, чтобы уменьшить время доступа к оперативной памяти.

### Режимы работы центрального процессора

Центральный процессор может работать в различных режимах, определяющих уровень доступа к системным ресурсам и защите данных. Основные режимы работы ЦПУ включают:

1. **Режим ядра (Supervisor Mode, Kernel Mode, Ring 0):**
    - **Описание:** Режим с максимальными привилегиями, позволяющий выполнять любые команды процессора и доступ к любой области памяти.
    - **Использование:** Выполнение операционной системы и её критических компонентов.
    - **Особенности:** В режиме ядра могут выполняться все инструкции ЦПУ, включая инструкции управления устройствами, управление памятью и выполнение системных вызовов.

2. **Пользовательский режим (User Mode, Ring 3):**
    - **Описание:** Режим с ограниченными привилегиями, предназначенный для выполнения прикладных программ.
    - **Использование:** Запуск приложений, игр, офисных программ и т.д.
    - **Особенности:** В пользовательском режиме доступ к системным ресурсам и критическим операциям ограничен. Попытка выполнения привилегированных инструкций приводит к генерации исключений и передаче управления операционной системе.

3. **Промежуточные режимы (Ring 1 и Ring 2):**
    - **Описание:** Эти режимы имеют привилегии, промежуточные между режимом ядра и пользовательским режимом.
    - **Использование:** В некоторых операционных системах для выполнения драйверов и некоторых системных служб.
    - **Особенности:** Редко используются в современных ОС, так как большинство системных служб выполняются либо в режиме ядра, либо в пользовательском режиме.

### Защита и переключение режимов

#### Защита памяти
Один из ключевых аспектов архитектуры ЦПУ — защита памяти, которая предотвращает несанкционированный доступ к памяти и данным. Это достигается с помощью механизмов, таких как сегментация и страничная организация памяти.

- **Сегментация:** Делит память на сегменты, каждый из которых имеет базовый адрес и предел. Процессор проверяет доступ к памяти на основе текущего сегмента и режима работы.
- **Страничная организация (Paging):** Делит память на страницы фиксированного размера и использует таблицы страниц для управления доступом. Обеспечивает защиту и изоляцию адресного пространства процессов.

#### Переключение режимов
Переключение между режимами ядра и пользовательским режимом осуществляется через механизмы системных вызовов и обработки исключений.

- **Системные вызовы:** Интерфейс, через который пользовательские приложения могут запрашивать услуги операционной системы (например, ввод-вывод, управление памятью и т.д.).
- **Обработка исключений:** Механизм, используемый для обработки ошибок и специальных условий, таких как деление на ноль или доступ к недопустимой памяти.

### Примеры архитектур и режимов работы

#### Архитектура x86 (Intel и AMD)
- **Режимы работы:** Реальный режим (Real Mode), защищенный режим (Protected Mode), режим виртуализации (Virtual Mode), режим системного управления (System Management Mode).
- **Реальный режим:** 16-битный режим, используемый в ранних ПК, с прямым доступом ко всей памяти.
- **Защищенный режим:** 32-битный режим, с поддержкой многозадачности, виртуальной памяти и защиты памяти.
- **Режим виртуализации:** Позволяет запускать виртуальные машины с помощью гипервизоров.
- **Режим системного управления:** Специальный режим для выполнения системного кода, такого как управление питанием.

#### Архитектура ARM
- **Режимы работы:** Режим пользователя, режим супервизора, режим прерываний, режим управления (monitor mode).
- **Особенности:** ARM процессоры часто используются в мобильных и встраиваемых системах, где эффективное управление энергопотреблением и высокая производительность имеют критическое значение.

### Заключение

Архитектура ЭВМ и режимы работы ЦПУ являются фундаментальными аспектами современных вычислительных систем. Различные режимы работы процессора обеспечивают разделение привилегий и защиту данных, способствуют эффективному выполнению задач и повышению безопасности системы. Понимание этих концепций является важным для разработки надежного и эффективного программного обеспечения.


# 2. Эволюция ОС

### Эволюция операционных систем

Операционные системы (ОС) играют ключевую роль в работе компьютеров, обеспечивая среду для выполнения программ и управления аппаратными ресурсами. Эволюция ОС представляет собой процесс развития от простых систем управления задачами до сложных многозадачных систем с графическим интерфейсом и сетевыми возможностями. Рассмотрим ключевые этапы эволюции операционных систем.

#### 1. Ранние операционные системы (1950-е годы)

**Первые ОС:**
- **Batch Processing Systems (Пакетные системы):** Пакетные системы стали первыми операционными системами, которые выполняли серию команд или программ без вмешательства пользователя. Программы и данные подготавливались заранее и вводились в систему в виде пакетов. Примеры: IBM 701, UNIVAC.

**Особенности:**
- Отсутствие интерактивного взаимодействия.
- Простое управление задачами.
- Ограниченные возможности.

#### 2. Временное разделение (1960-е годы)

**Разделение времени (Time-sharing):**
- **Multics (Multiplexed Information and Computing Service):** Одной из первых систем временного разделения была Multics, разработанная в MIT. Эта ОС позволяла нескольким пользователям одновременно взаимодействовать с системой, обеспечивая более эффективное использование ресурсов.

**Особенности:**
- Многозадачность (возможность выполнения нескольких задач одновременно).
- Поддержка нескольких пользователей.
- Улучшенное управление ресурсами.

#### 3. Появление Unix (1970-е годы)

**Unix:**
- **Разработка Unix:** В 1969 году Кен Томпсон и Деннис Ритчи из AT&T Bell Labs создали Unix, который стал одной из самых влиятельных операционных систем. Unix был написан на языке программирования C, что облегчило его переносимость на разные платформы.

**Особенности:**
- Многопользовательская система.
- Простая и эффективная структура.
- Файловая система с иерархической структурой.
- Мощные инструменты и утилиты для программирования.

#### 4. Появление персональных компьютеров (1980-е годы)

**MS-DOS и Windows:**
- **MS-DOS (Microsoft Disk Operating System):** В начале 1980-х годов Microsoft разработала MS-DOS, которая стала основной операционной системой для IBM PC. MS-DOS была однозадачной системой с командной строкой.
- **Windows:** В 1985 году Microsoft выпустила первую версию Windows, которая работала как графическая оболочка поверх MS-DOS. Со временем Windows эволюционировала в полноценную операционную систему с графическим интерфейсом и многозадачностью.

**Особенности:**
- Интерактивный графический интерфейс.
- Поддержка широкого спектра приложений.
- Постепенное развитие от однозадачной к многозадачной системе.

**Unix и его производные:**
- **BSD (Berkeley Software Distribution):** Unix-системы продолжали развиваться, и одним из значительных вкладов стала BSD, которая внесла множество улучшений и нововведений в Unix.
- **Linux:** В 1991 году Линус Торвальдс разработал ядро Linux, которое стало основой для множества Unix-подобных операционных систем. Linux быстро приобрел популярность благодаря своей открытости и гибкости.

#### 5. Расширение сетевых возможностей (1990-е годы)

**Сетевые ОС:**
- **Novell NetWare:** Одной из первых сетевых операционных систем была Novell NetWare, которая обеспечивала поддержку локальных сетей и файловых серверов.
- **Windows NT:** В 1993 году Microsoft выпустила Windows NT, которая была разработана с учетом сетевых возможностей и повышенной безопасности.

**Особенности:**
- Поддержка сетевых протоколов и служб.
- Повышенная безопасность и управление доступом.
- Сетевые файловые системы и ресурсы.

#### 6. Современные ОС (2000-е годы и далее)

**Современные ОС:**
- **Windows:** Серия Windows продолжала развиваться, начиная с Windows XP, Windows 7, Windows 10 и далее. Каждая новая версия приносила улучшения в области безопасности, производительности и пользовательского интерфейса.
- **MacOS:** Apple продолжала развивать свою операционную систему, начиная с Mac OS X (основанной на Unix), которая предложила мощный графический интерфейс и высокую производительность.
- **Linux:** Linux-системы продолжали расширять свою сферу применения, став основой для серверов, встраиваемых систем, мобильных устройств (например, Android) и облачных вычислений.

**Особенности:**
- Графические интерфейсы и улучшенные взаимодействие с пользователем.
- Расширенные возможности безопасности.
- Поддержка многозадачности и многопользовательских режимов.
- Интеграция с облачными сервисами и интернетом вещей (IoT).

### Основные тенденции и направления

**1. Мобильные операционные системы:**
- **Android и iOS:** Мобильные ОС, такие как Android и iOS, стали доминирующими на рынке смартфонов и планшетов. Они обеспечивают высокую производительность, безопасность и интеграцию с облачными сервисами.

**2. Облачные вычисления и виртуализация:**
- **Облачные ОС:** С развитием облачных технологий появились операционные системы, оптимизированные для работы в облачной среде, такие как Google Chrome OS.
- **Виртуализация:** Технологии виртуализации, такие как VMware и Hyper-V, позволяют запускать несколько операционных систем на одном физическом сервере, обеспечивая эффективное использование ресурсов.

**3. Безопасность и конфиденциальность:**
- Современные ОС уделяют большое внимание вопросам безопасности и конфиденциальности данных, включая шифрование, управление доступом и защиту от вредоносных программ.

**4. Интерфейсы и пользовательский опыт:**
- Операционные системы продолжают развивать интуитивные графические интерфейсы, улучшая взаимодействие с пользователем и интеграцию с различными устройствами.

### Заключение

Эволюция операционных систем отражает значительные изменения и инновации в области вычислительной техники. От простых пакетных систем до современных многозадачных и многопользовательских систем с графическим интерфейсом и сетевыми возможностями, операционные системы продолжают развиваться, адаптируясь к новым требованиям и технологиям. Понимание этой эволюции помогает разработчикам и пользователям осознавать текущие возможности и тенденции в области операционных систем.


# 3. Назначение и функции ОС

### Назначение и функции операционной системы (ОС)

Операционная система (ОС) — это программный комплекс, управляющий аппаратными ресурсами компьютера и обеспечивающий выполнение прикладных программ. ОС является посредником между пользователем, прикладными программами и аппаратным обеспечением компьютера, обеспечивая удобство, безопасность и эффективность их взаимодействия. Рассмотрим подробно назначение и функции операционной системы.

### Назначение операционной системы

1. **Управление ресурсами компьютера:**
    - ОС управляет всеми аппаратными ресурсами компьютера, включая центральный процессор (ЦПУ), оперативную память (RAM), устройства ввода-вывода (I/O), хранилища данных и сети.

2. **Обеспечение пользовательского интерфейса:**
    - ОС предоставляет пользователям интерфейс для взаимодействия с компьютером. Это может быть командная строка (CLI) или графический интерфейс (GUI).

3. **Поддержка выполнения программ:**
    - ОС обеспечивает среду для запуска и выполнения прикладных программ, управляя их доступом к аппаратным ресурсам и координируя их выполнение.

4. **Обеспечение безопасности и защиты данных:**
    - ОС обеспечивает механизмы защиты данных и ресурсов от несанкционированного доступа и сбоев.

5. **Организация файловой системы:**
    - ОС управляет файлами и директориями на дисковых устройствах, обеспечивая хранение, поиск, создание, удаление и доступ к данным.

### Основные функции операционной системы

#### 1. Управление процессами

**Управление процессами (Process Management):**
- **Создание и уничтожение процессов:** ОС создает процессы для выполнения программ и уничтожает их после завершения.
- **Планирование (Scheduling):** ОС решает, какой процесс должен выполняться в данный момент времени, используя различные алгоритмы планирования (например, Round Robin, приоритетное планирование).
- **Синхронизация процессов:** ОС обеспечивает механизм синхронизации для корректного взаимодействия между процессами, предотвращая состязательные ситуации.
- **Межпроцессное взаимодействие (Inter-process Communication, IPC):** ОС предоставляет средства для обмена данными между процессами, такие как очереди сообщений, каналы (pipes) и разделяемая память.

#### 2. Управление памятью

**Управление памятью (Memory Management):**
- **Разделение памяти:** ОС распределяет память между процессами, обеспечивая изоляцию и защиту данных.
- **Виртуальная память:** ОС использует виртуальную память для расширения доступного объема оперативной памяти с помощью дискового пространства, обеспечивая возможность выполнения программ, требующих больше памяти, чем доступно физически.
- **Память с защитой (Protected Memory):** ОС обеспечивает защиту памяти, предотвращая доступ одного процесса к памяти другого процесса, что повышает безопасность и стабильность системы.

#### 3. Управление файлами

**Управление файлами (File Management):**
- **Файловая система:** ОС организует данные на дисковых устройствах в виде файлов и директорий, обеспечивая удобный способ хранения и доступа к данным.
- **Операции с файлами:** ОС предоставляет операции для создания, удаления, чтения, записи и поиска файлов.
- **Доступ к файлам:** ОС управляет правами доступа к файлам и директориям, обеспечивая защиту данных от несанкционированного доступа.

#### 4. Управление устройствами ввода-вывода

**Управление устройствами ввода-вывода (I/O Management):**
- **Драйверы устройств:** ОС использует драйверы устройств для взаимодействия с аппаратными компонентами, такими как клавиатуры, мыши, принтеры, жесткие диски и сетевые карты.
- **Буферизация:** ОС обеспечивает буферизацию данных, что позволяет сглаживать разницу в скорости между процессором и устройствами ввода-вывода.
- **Асинхронный ввод-вывод:** ОС поддерживает асинхронный ввод-вывод, позволяя процессам продолжать выполнение, пока данные читаются или записываются.

#### 5. Управление пользователями и безопасностью

**Управление пользователями и безопасностью (User and Security Management):**
- **Аутентификация:** ОС обеспечивает механизмы проверки подлинности пользователей, такие как логины и пароли.
- **Авторизация:** ОС управляет правами доступа пользователей к системным ресурсам и данным.
- **Шифрование:** ОС поддерживает шифрование данных для защиты конфиденциальной информации.
- **Защита от вредоносных программ:** ОС предоставляет механизмы защиты от вирусов, червей и других вредоносных программ.

#### 6. Сетевые функции

**Сетевые функции (Network Management):**
- **Подключение к сети:** ОС поддерживает подключение к локальным и глобальным сетям, таким как Интернет.
- **Сетевые протоколы:** ОС реализует сетевые протоколы для обмена данными между компьютерами, такие как TCP/IP.
- **Сетевые службы:** ОС предоставляет сетевые службы, такие как файловые серверы, веб-серверы и почтовые серверы.

### Примеры операционных систем

1. **Windows:** Разработанная Microsoft, популярная ОС для персональных компьютеров, известная своим графическим интерфейсом и широким набором приложений.
2. **Linux:** Семейство Unix-подобных операционных систем с открытым исходным кодом, используемое на серверах, встраиваемых системах и десктопах.
3. **MacOS:** Операционная система от Apple для компьютеров Mac, известная своим дизайном и интеграцией с другими продуктами Apple.
4. **Android и iOS:** Мобильные операционные системы для смартфонов и планшетов, разработанные Google и Apple соответственно, с широкими возможностями для приложений и интернет-сервисов.

### Заключение

Операционные системы играют ключевую роль в функционировании компьютеров и мобильных устройств, обеспечивая управление ресурсами, безопасность данных и удобство взаимодействия с пользователями и приложениями. Развитие ОС продолжает идти в направлении повышения производительности, безопасности и интеграции с новыми технологиями, такими как облачные вычисления и интернет вещей. Понимание назначения и функций ОС является основой для разработки эффективных и надежных компьютерных систем.


# Структура ОС

### Структура операционной системы

Операционная система (ОС) — это сложный программный комплекс, состоящий из множества компонентов, каждый из которых выполняет определенные функции для обеспечения управления аппаратными ресурсами компьютера и выполнения приложений. Структура ОС описывает организацию этих компонентов и их взаимодействие. Существуют различные модели и подходы к построению ОС, включая монолитные, микроядерные и гибридные структуры. Рассмотрим основные структуры операционных систем и их характеристики.

#### 1. Монолитная структура

Монолитная структура ОС представляет собой модель, в которой все основные функции операционной системы, такие как управление процессами, памятью, вводом-выводом и файловой системой, реализованы в одном большом исполняемом модуле ядра.

**Характеристики:**
- **Единое ядро:** Все основные компоненты ОС включены в единое ядро, что обеспечивает высокую производительность благодаря непосредственному взаимодействию между компонентами.
- **Прямой доступ:** Компоненты ОС могут напрямую вызывать функции друг друга, что упрощает их разработку и улучшает производительность.
- **Сложность:** Большое количество кода в ядре может усложнить разработку и отладку системы, а также увеличить риск ошибок и сбоев.

**Примеры:** Linux, UNIX.

**Преимущества:**
- Высокая производительность.
- Простота межкомпонентного взаимодействия.

**Недостатки:**
- Сложность модификации и отладки.
- Уязвимость к ошибкам и сбоям в ядре.

#### 2. Микроядерная структура

Микроядерная структура ОС предполагает минимизацию функциональности ядра, оставляя в нем только базовые функции, такие как управление процессами и межпроцессное взаимодействие (IPC). Остальные функции ОС, такие как драйверы устройств, файловые системы и сетевые стеки, реализуются в виде пользовательских процессов.

**Характеристики:**
- **Минимальное ядро:** Ядро включает только минимально необходимый набор функций.
- **Модульность:** Основные функции ОС вынесены в отдельные процессы, что упрощает их модификацию и замену.
- **Безопасность:** Изоляция процессов увеличивает устойчивость к ошибкам и сбоям.

**Примеры:** Minix, QNX.

**Преимущества:**
- Упрощенная модификация и отладка.
- Повышенная устойчивость к сбоям и ошибки.

**Недостатки:**
- Более низкая производительность по сравнению с монолитными ядрами из-за накладных расходов на IPC.
- Сложность межпроцессного взаимодействия.

#### 3. Гибридная структура

Гибридная структура ОС сочетает элементы монолитных и микроядерных моделей, оставляя в ядре наиболее критичные для производительности компоненты, а менее критичные компоненты вынося в виде отдельных модулей или сервисов.

**Характеристики:**
- **Комбинированный подход:** Критически важные компоненты остаются в ядре, остальные реализуются как модули или процессы.
- **Гибкость:** Такая структура позволяет находить баланс между производительностью и модульностью.
- **Модульность:** Возможность динамической загрузки и выгрузки модулей улучшает управляемость и обновляемость системы.

**Примеры:** Windows NT, MacOS X.

**Преимущества:**
- Хороший баланс между производительностью и модульностью.
- Гибкость в модификации и обновлении компонентов.

**Недостатки:**
- Сложность архитектуры и реализации.
- Потенциальные накладные расходы на взаимодействие между модулями.

#### 4. Слойная структура

В слойной структуре ОС разделена на несколько уровней (слоев), каждый из которых выполняет определенные функции и взаимодействует только с соседними слоями. Такая организация упрощает разработку, отладку и тестирование ОС.

**Характеристики:**
- **Четкая организация:** Каждый слой выполняет конкретные функции и взаимодействует с верхним и нижним слоями.
- **Упрощенная модульность:** Легче добавлять, изменять и тестировать отдельные слои без воздействия на всю систему.

**Примеры:** THE (Technische Hogeschool Eindhoven), Multics.

**Преимущества:**
- Упрощенная разработка и тестирование.
- Модульность и возможность независимой разработки слоев.

**Недостатки:**
- Потенциальные накладные расходы на межслойное взаимодействие.
- Возможное усложнение взаимодействия между слоями.

### Компоненты операционной системы

Независимо от структуры, основные компоненты ОС включают:

1. **Ядро (Kernel):**
   - Центральный компонент ОС, управляющий ресурсами и обеспечивающий базовые функции, такие как управление процессами, памятью и устройствами ввода-вывода.

2. **Менеджер процессов (Process Manager):**
   - Управляет созданием, уничтожением, планированием и синхронизацией процессов.

3. **Менеджер памяти (Memory Manager):**
   - Управляет распределением и защитой памяти, поддерживает виртуальную память.

4. **Система ввода-вывода (I/O System):**
   - Обеспечивает интерфейс для взаимодействия с аппаратными устройствами и управляет буферизацией данных.

5. **Файловая система (File System):**
   - Организует хранение данных на дисковых устройствах, поддерживает операции с файлами и каталогами.

6. **Система защиты (Protection System):**
   - Обеспечивает безопасность и контроль доступа к ресурсам и данным.

7. **Сетевой стек (Network Stack):**
   - Обеспечивает сетевое взаимодействие и поддержку различных сетевых протоколов.

### Заключение

Структура операционной системы определяет организацию ее компонентов и их взаимодействие. Существуют различные подходы к построению ОС, включая монолитные, микроядерные, гибридные и слойные структуры, каждая из которых имеет свои преимущества и недостатки. Понимание структуры ОС и ее компонентов важно для разработки, эксплуатации и оптимизации компьютерных систем.

# 5. Классификация ОС

### Классификация операционных систем

Операционные системы (ОС) можно классифицировать по различным критериям, таким как типы обслуживаемых устройств, способы взаимодействия с пользователем, степень многозадачности, модели использования и другие. Рассмотрим основные типы классификации операционных систем.

#### 1. По типу обслуживаемых устройств

**1.1. Операционные системы для мейнфреймов:**
- Используются на крупных вычислительных машинах (мейнфреймах), которые обслуживают множество пользователей и выполняют большое количество задач одновременно.
- Примеры: IBM z/OS, IBM z/VM.

**1.2. Операционные системы для серверов:**
- Оптимизированы для работы в серверных средах, предоставляют высокую надежность, производительность и средства управления ресурсами.
- Примеры: Microsoft Windows Server, Linux (различные дистрибутивы, такие как Ubuntu Server, CentOS, Red Hat Enterprise Linux).

**1.3. Операционные системы для настольных ПК:**
- Предназначены для персональных компьютеров, ориентированы на взаимодействие с пользователем, имеют графический интерфейс и поддерживают широкий спектр приложений.
- Примеры: Microsoft Windows (Windows 10, Windows 11), macOS, Linux (дистрибутивы, такие как Ubuntu, Fedora).

**1.4. Операционные системы для мобильных устройств:**
- Оптимизированы для смартфонов, планшетов и других мобильных устройств, обеспечивают управление энергопотреблением и поддержку сенсорного ввода.
- Примеры: Android, iOS.

**1.5. Операционные системы для встроенных систем:**
- Применяются в специализированных устройствах, таких как бытовая техника, автомобили, промышленные контроллеры. Часто имеют ограниченные ресурсы и требуют высокой надежности.
- Примеры: FreeRTOS, VxWorks, QNX.

#### 2. По способу взаимодействия с пользователем

**2.1. Операционные системы с пакетной обработкой:**
- Обрабатывают задания пакетами, без непосредственного взаимодействия с пользователем. Подходят для выполнения длинных и ресурсозатратных задач.
- Примеры: IBM z/OS, ранние версии Unix.

**2.2. Операционные системы с разделением времени:**
- Поддерживают многозадачность с разделением времени, позволяя нескольким пользователям взаимодействовать с системой одновременно через терминалы.
- Примеры: Multics, Unix, Linux.

**2.3. Операционные системы реального времени:**
- Обеспечивают гарантированное выполнение задач в строгие временные рамки. Критичны для управления техническими процессами и встроенных систем.
- Примеры: VxWorks, RTEMS, FreeRTOS.

**2.4. Операционные системы с графическим интерфейсом пользователя (GUI):**
- Предоставляют пользователям графический интерфейс для взаимодействия с системой, что упрощает использование и освоение.
- Примеры: Microsoft Windows, macOS, различные дистрибутивы Linux с графическими оболочками (например, GNOME, KDE).

#### 3. По степени многозадачности

**3.1. Однозадачные операционные системы:**
- Поддерживают выполнение только одной задачи в один момент времени.
- Примеры: MS-DOS, ранние версии операционных систем для микрокомпьютеров.

**3.2. Многозадачные операционные системы:**
- Поддерживают одновременное выполнение нескольких задач, распределяя процессорное время между ними.
- Примеры: Unix, Linux, Windows, macOS.

#### 4. По числу пользователей

**4.1. Однопользовательские операционные системы:**
- Предназначены для использования одним пользователем в одно время.
- Примеры: MS-DOS, ранние версии Windows (до Windows 95).

**4.2. Многопользовательские операционные системы:**
- Поддерживают одновременное взаимодействие нескольких пользователей с системой.
- Примеры: Unix, Linux, Windows Server.

#### 5. По модели использования

**5.1. Настольные операционные системы:**
- Ориентированы на использование на персональных компьютерах и обеспечивают поддержку приложений для повседневных задач.
- Примеры: Microsoft Windows, macOS, Linux.

**5.2. Серверные операционные системы:**
- Оптимизированы для использования на серверах, обеспечивают высокую надежность, производительность и возможности для управления сетями и ресурсами.
- Примеры: Windows Server, Linux (CentOS, Ubuntu Server), Unix (AIX, Solaris).

**5.3. Мобильные операционные системы:**
- Разработаны для работы на мобильных устройствах, обеспечивают управление энергопотреблением и поддержку сенсорного ввода.
- Примеры: Android, iOS.

**5.4. Встроенные операционные системы:**
- Используются в специализированных устройствах с ограниченными ресурсами, такими как бытовая техника и промышленные контроллеры.
- Примеры: FreeRTOS, VxWorks, QNX.

#### 6. По архитектуре ядра

**6.1. Монолитные ядра:**
- Все основные функции ОС реализованы в одном большом модуле ядра.
- Примеры: Linux, традиционные Unix-системы.

**6.2. Микроядра:**
- Ядро включает только базовые функции, остальные компоненты ОС реализуются в виде отдельных процессов.
- Примеры: Minix, QNX.

**6.3. Гибридные ядра:**
- Сочетают элементы монолитных и микроядерных архитектур, оставляя в ядре критически важные компоненты, а остальные реализуя как модули.
- Примеры: Windows NT, macOS.

#### 7. По способу лицензирования

**7.1. Проприетарные операционные системы:**
- Распространяются по коммерческим лицензиям, исходный код закрыт.
- Примеры: Microsoft Windows, macOS.

**7.2. Операционные системы с открытым исходным кодом:**
- Исходный код доступен для изучения, модификации и распространения. Часто распространяются бесплатно.
- Примеры: Linux, FreeBSD.

### Заключение

Классификация операционных систем по различным критериям помогает лучше понять их разнообразие и особенности. ОС можно классифицировать по типу обслуживаемых устройств, способу взаимодействия с пользователем, степени многозадачности, числу пользователей, модели использования, архитектуре ядра и способу лицензирования. Эти классификации помогают выбрать подходящую операционную систему для конкретных задач и условий эксплуатации.


# 6. Стандарт POSIX

### Стандарт POSIX: Подробный разбор

POSIX (Portable Operating System Interface) — это семейство стандартов, разработанных IEEE (Institute of Electrical and Electronics Engineers) для обеспечения совместимости и портативности между операционными системами. Стандарт POSIX определяет интерфейсы и поведение операционной системы, позволяя приложениям, написанным для одной POSIX-совместимой системы, работать на других таких системах с минимальными изменениями.

#### История и развитие

POSIX был разработан в ответ на необходимость унификации различных версий UNIX и других операционных систем, которые стали популярными в 1980-х годах. В те времена существовало множество разновидностей UNIX, каждая со своими уникальными особенностями, что создавало проблемы для разработчиков программного обеспечения.

Проект POSIX начался в 1985 году, и первый стандарт был опубликован в 1988 году как POSIX.1. С тех пор стандарт POSIX был расширен и обновлен, включив новые функциональности и учитывая изменения в технологиях.

#### Основные компоненты и спецификации POSIX

POSIX состоит из нескольких частей, каждая из которых охватывает разные аспекты операционной системы. Основные компоненты включают:

**1. POSIX.1 (IEEE Std 1003.1):**
- Определяет базовые системные интерфейсы для операционных систем, включая управление процессами, файловую систему, работу с вводом-выводом и другие основные функции.
- Включает функции стандартной библиотеки языка программирования C (libc).

**2. POSIX.2 (IEEE Std 1003.2):**
- Определяет командный интерпретатор (shell) и стандартные утилиты командной строки, такие как `ls`, `cp`, `mv`, `grep`, `awk` и другие.
- Описывает синтаксис и семантику командной строки и сценариев (shell scripts).

**3. POSIX.4 (IEEE Std 1003.4):**
- Описывает расширения для поддержки реального времени, включая приоритетное планирование, семафоры, таймеры и асинхронный ввод-вывод.

**4. POSIX.5 (IEEE Std 1003.5):**
- Определяет интерфейсы для языка программирования Ada.

**5. POSIX.6 (IEEE Std 1003.6):**
- Описывает системы управления безопасностью, включая модели контроля доступа и управления правами.

**6. POSIX.7 (IEEE Std 1003.7):**
- Включает спецификации для системных служб и прикладных интерфейсов.

**7. POSIX.8 и последующие:**
- Покрывают дополнительные аспекты и расширения, такие как поддержка сетевых функций, интерфейсы для других языков программирования (например, Fortran), а также требования к тестированию совместимости.

#### Ключевые концепции и функции POSIX

**1. Файловая система и ввод-вывод:**
- POSIX определяет интерфейсы для работы с файлами, такими как открытие, чтение, запись, закрытие файлов, а также управление файловыми атрибутами и правами доступа.
- Включает функции для работы с потоками ввода-вывода, как синхронного, так и асинхронного.

**2. Управление процессами:**
- POSIX стандартизирует функции для создания, управления и завершения процессов, включая функции `fork()`, `exec()`, `wait()`, и сигналы.
- Определяет средства межпроцессного взаимодействия (IPC), такие как пайпы, очереди сообщений, семафоры и разделяемая память.

**3. Потоки (threads):**
- POSIX включает спецификации для многопоточности, известные как POSIX Threads (pthreads). Эти спецификации определяют интерфейсы для создания и управления потоками, синхронизации потоков с помощью мьютексов и условных переменных.

**4. Сетевые интерфейсы:**
- POSIX включает спецификации для работы с сетями, такие как сокеты, которые позволяют приложениям взаимодействовать через сеть.

**5. Временные функции:**
- Определяет интерфейсы для работы с системным временем, таймерами и задержками.

**6. Безопасность и контроль доступа:**
- Включает модели управления правами доступа к файлам и ресурсам, такие как списки контроля доступа (ACL).

#### Реализации и совместимость

Множество операционных систем стремятся к соответствию стандарту POSIX для обеспечения портативности приложений. Среди них:

- **UNIX и UNIX-подобные системы:** Большинство современных UNIX-систем (например, Solaris, AIX, HP-UX) и Linux-дистрибутивов (например, Ubuntu, CentOS) поддерживают POSIX.
- **BSD-системы:** FreeBSD, OpenBSD, NetBSD также совместимы с POSIX.
- **Windows:** Через среду совместимости Cygwin и подсистему Windows для Linux (WSL) можно использовать POSIX-совместимые приложения на Windows.

#### Значение стандарта POSIX

**1. Портативность:**
- POSIX позволяет разработчикам создавать приложения, которые могут работать на различных операционных системах без значительных изменений в коде.

**2. Интероперабельность:**
- Стандартизация интерфейсов и функциональности облегчает взаимодействие между разными системами и компонентами программного обеспечения.

**3. Упрощение разработки:**
- Наличие единого набора стандартов упрощает процесс разработки, тестирования и отладки программного обеспечения.

**4. Снижение затрат:**
- Портативность и стандартизация помогают снизить затраты на поддержку и модификацию программного обеспечения, так как один и тот же код можно использовать на различных системах.

### Заключение

POSIX является важным стандартом, который обеспечивает совместимость и портативность между различными операционными системами. Он охватывает широкий спектр функций, от управления процессами и памятью до сетевых взаимодействий и безопасности. POSIX играет ключевую роль в развитии и поддержке многоплатформенных приложений, облегчая жизнь разработчикам и повышая эффективность программных решений.

# 7. Единицы измерения количества информации

### Единицы измерения количества информации

Измерение количества информации важно в различных областях, таких как информатика, телекоммуникации и хранение данных. Существуют разные системы и стандарты для измерения информации, включая традиционные единицы, такие как байты и биты, а также новые стандарты, введенные для устранения путаницы.

#### Традиционные единицы измерения информации

**1. Бит (bit):**
- Основная единица измерения информации.
- Обозначает двоичную цифру (0 или 1).
- Используется для измерения количества данных и пропускной способности (например, бит/секунда).

**2. Байты (byte):**
- 1 байт = 8 бит.
- Используется для измерения объема данных и памяти.
- Один байт может представлять один символ текста в большинстве кодировок (например, ASCII).

#### Кратные единицы байта

Для удобства измерения больших объемов данных используются кратные единицы байта, такие как килобайт (KB), мегабайт (MB), гигабайт (GB) и т.д.

**1. Десятичная система (основана на степенях 10):**
- 1 килобайт (KB) = 10^3 байт = 1,000 байт.
- 1 мегабайт (MB) = 10^6 байт = 1,000,000 байт.
- 1 гигабайт (GB) = 10^9 байт = 1,000,000,000 байт.
- 1 терабайт (TB) = 10^12 байт = 1,000,000,000,000 байт.

**2. Двоичная система (основана на степенях 2):**
- 1 килобайт (KB) = 2^10 байт = 1,024 байт.
- 1 мегабайт (MB) = 2^20 байт = 1,048,576 байт.
- 1 гигабайт (GB) = 2^30 байт = 1,073,741,824 байт.
- 1 терабайт (TB) = 2^40 байт = 1,099,511,627,776 байт.

#### Проблема путаницы

Смешение десятичных и двоичных префиксов часто приводит к путанице. Например, производители жестких дисков обычно используют десятичные префиксы, а операционные системы и многие программы — двоичные.

#### Введение кибибайтов и других двоичных префиксов

Чтобы устранить путаницу между десятичными и двоичными префиксами, Международная электротехническая комиссия (IEC) в 1998 году ввела новые префиксы для двоичных кратных единиц.

**Двоичные префиксы (по стандарту IEC):**
- 1 кибибайт (KiB) = 2^10 байт = 1,024 байт.
- 1 мебибайт (MiB) = 2^20 байт = 1,048,576 байт.
- 1 гибибайт (GiB) = 2^30 байт = 1,073,741,824 байт.
- 1 тебибайт (TiB) = 2^40 байт = 1,099,511,627,776 байт.
- 1 пебибайт (PiB) = 2^50 байт = 1,125,899,906,842,624 байт.
- 1 эксбибайт (EiB) = 2^60 байт = 1,152,921,504,606,846,976 байт.

#### Сравнение с десятичными префиксами

Для ясности приведем сравнение десятичных и двоичных префиксов:

| Десятичный префикс | Значение (в байтах) | Двоичный префикс | Значение (в байтах)    |
|--------------------|---------------------|------------------|-----------------------|
| 1 килобайт (KB)    | 1,000 байт          | 1 кибибайт (KiB) | 1,024 байт            |
| 1 мегабайт (MB)    | 1,000,000 байт      | 1 мебибайт (MiB) | 1,048,576 байт        |
| 1 гигабайт (GB)    | 1,000,000,000 байт  | 1 гибибайт (GiB) | 1,073,741,824 байт    |
| 1 терабайт (TB)    | 1,000,000,000,000 байт | 1 тебибайт (TiB) | 1,099,511,627,776 байт |

#### Стандарты ГОСТ и IEC

**ГОСТ (Государственный стандарт):**
- В России используются стандарты ГОСТ, которые согласуются с международными стандартами ISO и IEC.
- ГОСТ 8.417-2002: включает рекомендации по использованию единиц измерения количества информации, поддерживая двоичные и десятичные префиксы.

**IEC (International Electrotechnical Commission):**
- IEC 60027-2 и IEC 80000-13: вводят двоичные префиксы, чтобы различать десятичные и двоичные значения.

#### Заключение

Единицы измерения количества информации включают биты и байты, а также их кратные в десятичной и двоичной системах. Для устранения путаницы между десятичными и двоичными кратными введены новые префиксы, такие как кибибайты, мебибайты и другие. Стандарты ГОСТ и IEC регулируют использование этих единиц, обеспечивая согласованность и точность в измерении информации.


# 8. Процессы. Создание и завершение процессов

### Процессы: Создание и завершение

#### Введение

Процесс — это программа в состоянии выполнения, являющаяся основной единицей работы для операционной системы (ОС). Процесс включает не только исполняемый код программы, но и ее состояние, включая значения регистров, переменных и другие контексты, необходимые для выполнения программы. Управление процессами — это одна из ключевых функций любой ОС.

#### Создание процессов

Создание процессов может происходить различными способами в зависимости от ОС, но основные концепции остаются схожими. Рассмотрим создание процессов на примере Unix-подобных систем, таких как Linux, и Windows.

**1. Unix-подобные системы:**

В Unix-подобных системах процессы создаются с помощью системных вызовов `fork()` и `exec()`. Процесс создания включает несколько этапов:

- **Системный вызов `fork()`:**
   - `fork()` создает новый процесс, который является копией текущего процесса.
   - Новый процесс называется дочерним процессом, а исходный — родительским процессом.
   - Дочерний процесс получает копию всех сегментов памяти родительского процесса (код, данные, стек и т.д.).
   - Возвращает значение 0 для дочернего процесса и идентификатор дочернего процесса (PID) для родительского процесса.

Пример кода на C:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid < 0) {
        // Ошибка создания процесса
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Это дочерний процесс
        printf("Hello from the child process!\n");
    } else {
        // Это родительский процесс
        printf("Hello from the parent process! Child PID: %d\n", pid);
    }
    
    return 0;
}
```

- **Системный вызов `exec()`:**
   - `exec()` заменяет текущий процесс новым, загружая новую программу в адресное пространство процесса.
   - Существует несколько вариаций `exec()`, таких как `execl()`, `execv()`, `execle()`, `execve()`, и т.д.
   - После успешного вызова `exec()`, текущий процесс уже не существует, и исполняется новая программа.

Пример использования `exec()` в дочернем процессе:

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid < 0) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Дочерний процесс
        execlp("/bin/ls", "ls", NULL);
        // Если exec неудачен, то выполнить
        perror("exec failed");
        return 1;
    } else {
        // Родительский процесс
        printf("Hello from the parent process! Child PID: %d\n", pid);
    }
    
    return 0;
}
```

**2. Windows:**

В Windows процессы создаются с помощью функции `CreateProcess()`. Этот вызов создает новый процесс и поток.

Пример кода на C:

```c
#include <windows.h>
#include <stdio.h>

int main() {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (!CreateProcess(NULL,   // Имя исполняемого модуля
        "C:\\Windows\\System32\\notepad.exe", // Командная строка
        NULL,            // Процессные атрибуты
        NULL,            // Атрибуты потока
        FALSE,           // Унаследовать дескрипторы
        0,               // Флаги создания
        NULL,            // Переменные среды
        NULL,            // Текущий каталог
        &si,             // Структура информации о запуске
        &pi))            // Структура информации о процессе
    {
        printf("CreateProcess failed (%d).\n", GetLastError());
        return 1;
    }

    // Ждем завершения дочернего процесса.
    WaitForSingleObject(pi.hProcess, INFINITE);

    // Закрываем дескрипторы.
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return 0;
}
```

#### Завершение процессов

Процесс может завершиться по собственной инициативе или быть завершенным внешними силами (например, другой программой или пользователем).

**1. Естественное завершение:**
- Процесс завершает свое выполнение, достигнув конца своего кода или вызвав системный вызов для завершения (`exit()` в Unix, `ExitProcess()` в Windows).

Пример естественного завершения в Unix-подобных системах:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    printf("Process will exit now.\n");
    exit(0);
}
```

**2. Принудительное завершение:**
- Процесс может быть завершен принудительно с помощью внешнего вмешательства, такого как сигнал в Unix (`kill`) или вызов функции в Windows (`TerminateProcess`).

Пример завершения процесса с использованием сигнала в Unix:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

int main() {
    pid_t pid = fork();
    
    if (pid < 0) {
        perror("fork failed");
        return 1;
    } else if (pid == 0) {
        // Дочерний процесс
        printf("Child process running with PID: %d\n", getpid());
        while (1); // Бесконечный цикл
    } else {
        // Родительский процесс
        sleep(2); // Ждать 2 секунды
        kill(pid, SIGKILL); // Завершить дочерний процесс
        printf("Child process terminated\n");
    }
    
    return 0;
}
```

Пример завершения процесса в Windows:

```c
#include <windows.h>
#include <stdio.h>

int main() {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (!CreateProcess(NULL, "C:\\Windows\\System32\\notepad.exe", NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        printf("CreateProcess failed (%d).\n", GetLastError());
        return 1;
    }

    // Ждем 2 секунды, прежде чем завершить процесс.
    Sleep(2000);
    TerminateProcess(pi.hProcess, 0);

    // Закрываем дескрипторы.
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    printf("Process terminated\n");

    return 0;
}
```

#### Заключение

Процессы — это фундаментальные единицы выполнения в операционных системах, которые позволяют пользователям и системам выполнять программы. Создание процессов включает в себя механизмы копирования текущего процесса (например, `fork()`) и загрузки новых программ в процесс (например, `exec()`). Завершение процессов может происходить как естественным образом, так и принудительно через внешние вмешательства. Управление процессами является критически важным для обеспечения стабильности, безопасности и эффективности работы операционной системы.
